# -*- coding: utf-8 -*-
"""KMAP_solvr.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1Phvrxr51aVtHF2tOJxUuXJeV4Aa2GzBE
"""

import numpy as np

def ArrayComparison(A,kernel):
    '''
    Helper function to compare two arrays
    '''
    #row=A.shape[0]
    #col=A.shape[1]
    #for i in range(row):
        #for j in range(col):
            #if A[i][j]!=kernel[i][j]:
                #return False
    #return True
    #vectorizing the previous code
    return np.array_equal(A,kernel)
def convolution(A,kernel):
    '''
        Convolution operation to get know wheather a filter is present in k map or not
    '''
    kernel_row=kernel.shape[0]
    kernel_col=kernel.shape[1]
    row=A.shape[0]
    col=A.shape[1]
    kernel_list=[]
    for i in range(row-kernel_row+1):
        for j in range(col-kernel_col+1):
            if ArrayComparison(A[i:i+kernel_row,j:j+kernel_col]*kernel,kernel)==True:
                #print(A[i:i+kernel_row,j:j+kernel_col])
                kernel_list.append(np.asarray([[i,i+kernel_row],[j,j+kernel_col]]))
    return kernel_list
def k_mapFilters():
    '''
        return filers which can be grouped in k map

        these filters are used to group ones in 4x4 kmap

        15 different filters are used to group 1's in all different possible logical forms
    '''
    A=[]
    from numpy import asarray
    from numpy import ones
    A.append(ones((4,4)))
    temp=asarray([[1,1,1,1],[1,1,1,1]])
    A.append(temp)  
    A.append(temp.T)  
    temp=asarray([[1,1,1,1],[0,0,0,0],[0,0,0,0],[1,1,1,1]])
    A.append(temp)
    A.append(temp.T)
    temp=asarray([[1,0,0,1],[1,0,0,1]])
    A.append(temp)  
    A.append(temp.T)  
    temp=asarray([[1,1,1,1]])
    A.append(temp) 
    A.append(temp.T) 
    A.append(ones((2,2))) 
    temp=asarray([[1,0,0,1],[0,0,0,0],[0,0,0,0],[1,0,0,1]])
    A.append(temp) 
    temp=asarray([[1,1]])
    A.append(temp) 
    A.append(temp.T)
    temp=asarray([[1,0,0,1]])
    A.append(temp)
    A.append(temp.T)
    return A

def Extract_Logic(location,kernel):
  '''
  Extracting logic by thier locations
  '''
  rows=kernel.shape[0]
  cols=kernel.shape[1]
  buffer_list=[]
  for row in range(rows):
    for col in range(cols):
      if kernel[row,col]==1:
        buffer_list.append(location[row,col])
  return buffer_list

"""Commented out the print statement in convolution"""

class Hash:
  def __init__(self,data):
    self.data=data
    self.visited=False
    self.dont_care=False

def Hash_Map(k_map,present_dont_care,Gray_Array):
  '''
  Building A hash map for keep track of visited Ones
  '''
  rows=k_map.shape[0]
  cols=k_map.shape[1]
  hash_list=[]
  for row in range(rows):
    for col in range(cols):
      hash_list.append(Hash(k_map[row,col]))
      if present_dont_care[Gray_Array[row,col]]==True:
        hash_list[-1].dont_care=True #newly inserted element is a dont care one
  hash_list=np.asarray(hash_list)
  hash_list=hash_list.reshape((rows,cols))
  return hash_list

def Exit_Condition(hash_list):
  '''
  After All ones are grouped this function prevents to apply future more kernels
  '''
  rows=hash_list.shape[0]
  cols=hash_list.shape[1]
  for row in range(rows):
    for col in range(cols): 
      if hash_list[row,col].data==1 and hash_list[row,col].visited==False and hash_list[row,col].dont_care==False:
        return False
  return True

def Apply_Kernel(hash_list,kernel_locations,kernel):
  '''
  This function marks all the visited ones by a kernel True
  '''
  kernel_row_start=kernel_locations[0,0]
  kernel_row_end=kernel_locations[0,1]
  kernel_col_start=kernel_locations[1,0]
  kernel_col_end=kernel_locations[1,1]
  row=0
  for i in range(kernel_row_start,kernel_row_end):
    col=0
    for j in range(kernel_col_start,kernel_col_end):
      if kernel[row,col]==1:
        hash_list[i,j].visited=True
      col+=1
    row+=1

def monitor(hash_list):
  '''
  Just For Debugging
  '''
  rows=hash_list.shape[0]
  cols=hash_list.shape[1]
  for row in range(rows):
    for col in range(cols):
      print(hash_list[row,col].data," ",hash_list[row,col].visited," ",end=" ")
    print("")

"""Small Change in Apply kernel"""

def location_validity(hash_list,kernel,kernel_locations):
  '''
  this function validates wheather a filter stride included a new unvisited 1 or not
  '''
  kernel_row_start=kernel_locations[0,0]
  kernel_row_end=kernel_locations[0,1]
  kernel_col_start=kernel_locations[1,0]
  kernel_col_end=kernel_locations[1,1]
  row=0
  for i in range(kernel_row_start,kernel_row_end):
    col=0
    for j in range(kernel_col_start,kernel_col_end):
      if hash_list[i,j].data==1 and hash_list[i,j].visited==False and kernel[row,col]==1 and hash_list[i,j].dont_care==False:
        return True
      col+=1
    row+=1
  return False

"""passing kernel to location_validity"""

def process(locations):
  '''
  coverting Gray Scale locations into binary Grid form
  '''
  Grid=[]
  for number in locations:
    buffer_array=np.zeros(4)
    i=3
    while number>0 and i>=0:
      buffer_array[i]=number%2
      number=number//2
      i=i-1
    Grid.append(buffer_array)
  Grid=np.asarray(Grid)
  return Grid

def kernel_logic(locations,result):
  '''
  to obtain logic from gray locations
  '''
  Grid=process(locations)
  rows=Grid.shape[0]
  cols=Grid.shape[1]
  Mean_Terms=['A','B','C','D']
  Mean_Terms_Complients=["A'","B'","C'","D'"]
  Ones_Array=np.ones((rows))
  Zeros_Array=np.zeros((rows))
  for i in range(cols):
    if ArrayComparison(Ones_Array,Grid[:,i])==True:
      result+=Mean_Terms[i]
    elif ArrayComparison(Zeros_Array,Grid[:,i])==True:
      result+=Mean_Terms_Complients[i]
  return result
def kmap_format(hash_list):
  rows=hash_list.shape[0]
  cols=hash_list.shape[1]
  for row in range(rows):
    for col in range (cols):
      if hash_list[row,col].data==1 and hash_list[row,col].dont_care==False:
        print(1,end="  ")
      elif hash_list[row,col].data==1 and hash_list[row,col].dont_care==True:
        print("X",end="  ")
      else:
        print(0,end="  ")
    print()
def main(k_map,present_dont_care):
  result_logic=''
  import numpy as np
  Gray_Array=np.asarray([[0,1,3,2],[4,5,7,6],[12,13,15,14],[8,9,11,10]]) #to map filters to gray scale values for logic output
  filters=k_mapFilters()
  print("Actual K_map")
  count=0
  hash_list=Hash_Map(k_map,present_dont_care,Gray_Array)
  kmap_format(hash_list)
  print('------------------------')
  for x in filters:
      kernel_list=convolution(k_map,x)
      if len(kernel_list)!=0:
          for locations in kernel_list:
            kernel_row_start=locations[0,0]
            kernel_row_end=locations[0,1]
            kernel_col_start=locations[1,0]
            kernel_col_end=locations[1,1]
            Groups_1=Extract_Logic(Gray_Array[kernel_row_start:kernel_row_end,kernel_col_start:kernel_col_end],x)
            if location_validity(hash_list,x,locations)==True:
              print("Filter present in k_map")
              print(x)
              print("-----------------------")
              print("At Gray Scale location:")
              result_logic=kernel_logic(Groups_1,result_logic)+" + "
              print(Groups_1)
              print("-----------------------")
              #print(locations) for debugging
              Apply_Kernel(hash_list,locations,x)
              #monitor(hash_list) for debugging
            if Exit_Condition(hash_list)==True:
              print("k-Map Simplification Complete:")
              print("Resulant Logic:",result_logic[0:-2])
              return 0
          #print('-----------------------')
          count+=len(kernel_list)
  rows=hash_list.shape[0]
  cols=hash_list.shape[1]
  locations=[]
  for row in range(rows):
    for col in range(cols):
      if hash_list[row,col].data==1 and hash_list[row,col].visited==False:
        locations.append(Gray_Array[row,col]) 
        result_logic=kernel_logic(locations,result_logic)+" + "
        locations.pop()
  print("k-Map Simplification Complete:")
  print("Resulant Logic:",result_logic[0:-2])
def kmap_input(Ones_list,Dont_Care_list):
  import numpy as np
  Gray_Array=np.asarray([[0,1,3,2],[4,5,7,6],[12,13,15,14],[8,9,11,10]])
  k_map=np.zeros((4,4))
  rows=Gray_Array.shape[0]
  cols=Gray_Array.shape[1]
  present=dict()
  present_dont_care=dict()
  for row in range(rows):
    for col in range(cols):
      present[Gray_Array[row,col]]=False
      present_dont_care[Gray_Array[row,col]]=False
  n=len(Ones_list)
  for i in range(n):
    present[int(Ones_list[i])]=True
  n=len(Dont_Care_list)
  for i in range(n):
    present_dont_care[int(Dont_Care_list[i])]=True
  for row in range(rows):
    for col in range(cols):
      if present[Gray_Array[row,col]]==True or present_dont_care[Gray_Array[row,col]]==True:
        k_map[row,col]=1
  main(k_map,present_dont_care)

import sys
Ones_list=sys.argv[1].split(',')
Dont_Care_list=sys.argv[2].split(',')
kmap_input(Ones_list,Dont_Care_list)

"""Completed"""